

## 控制台调式

- console.table()；： 可以以index和value的表格方式查看输出结果
- 计算代码或函数执行的耗时

```js
// 设置一个定时器 用aaa 标识 最后它会计算这段代码的总耗时 以毫秒为单位
console.time('aaa');

function test(a, b) {
    return a + b;
}
let a = test(1, 2);

console.timeEnd('aaa')
```





## babel转换工具

注释：初始化 npm init -y

- ```js
  // 安装转换工具 babel-preset-es2015
  npm install --save-dev babel-preset-es2015 babel-cli
  ```

- 新建： .babelrc文件 输入下面内容

  ```js
  {
    "presets":["es2015"],
    "plugins":[]
  }
  ```

  

- ```js
  // 表示将src文件的es6代码转换成es5代码输出到dis/index目录文件夹
  babel src/index.js -o dist/index.js
  
  ----每次转换输入以上代码过于繁琐 
  // 直接到package.json 文件内的 srcipts对象字段内进行配置
    "scripts": {
       // 如果是vue项目这里还可以添加怎么启动项目的命令
      "build": "babel src/index.js -o dist/index.js"
    },
  // 之后每次转换直接输入npm run build 即可启动
  ```

  之后就能实现es6转es5了



## 拓展运算符和rest运算符

```js
function fn1(first,...arg){ // 如果只有arg就是拓展运算得到全部值
    for(let item of arg){
        console.log(item)
        console.log(first);
    }}
fn1(1,2,3,4,5,6,7)
// rest意为休止，剩余， 即first得到第一个值，剩余的值全部赋予arg,
```



## 对象的函数结构

```js
let json = {
    a:"jspa",
    b:'技术胖'
}
function fun({a,b}){ // 需要与对象的键名对应上
    console.log(a,b)
}
fun(json) // 将对象作为参数传入即可
```



## 对象的判断 in

- 判断某个属性是否存在于指定对象当中


```js
let obj = {a:'ldh', b:'zxy'}
console.log('a' in obj) // obj里面是否有元素a  true
console.log(0 in obj) // 空位判断 索引0 是否有值 返回布尔值
```



## const

- const声明的变量不允许被重新赋值或修改
- const声明的对象同样不允许被重新定义，但是值可以被修改

## 箭头函数

- 箭头函数不能使用 arguments 、 super 和new.target ，也不能用作构造函数。且箭头函数也没有 prototype 属性和自己的this，它的this是继承上下文的this，也就是他的包装函数(就是函数嵌套)
- 

# 元素检测/数组/字符

```js
// startsWith() endsWith() 查找开头 和结尾 只能查找字符串
// 接收2个参数 1：要查找的字符，2：开始查找的位置
var str = "Hello world, welcome to the Runoob.";
var n = str.startsWith("Hello");
```



## indexOf查找

查找数组/字符元素 ：接收2个参数：查找元素，查找开始位置。

- 找到返回元素第一次出现的位置，未找到返回-1，
- 注意：如果执行的是严格查找只能查找Number类型 非严格查找数组也可以使用 indexOf

```js
let a = 'hello xjj';
console.log(a.indexOf('0',1)) // 索引位置4 
```



## includes查找

查找数组/字符元素：接收2个参数：查找元素，查找开始位置默认索引0。

-  返回布尔值 true/false, 找到第一个满足条件的元素 即停止查询, 区分大小写
-  可用于模糊查找，

```js
let a = 'hello xjj';
console.log(a.includes('o',1)); // true
data.some(item =>{
// 模糊查找 只要元素包含查找条件的任意因素即可，比如查小米,只要出现小字即可匹配到相关元素项
    if(item.xxx.includes(input.value)){
        return item;
    }
})
```



## find与findIndex查找/检测

主要解决了针对引用类型数据的查找，不改变原数组，功能由回调函数提供

1. 语法：element.find(function(){return xxx});  回调函数内接受3个参数
   1. item  被遍历的每一项元素
   2. index 被遍历的元素索引号
   3. element   数组本身

- 返回第一个满足条件的元素值，未找到返回undefined
- 会对数组每一项包括空值执行回调函数，空值为undefined

findIndex:与fund类似， 区别在于findIndex返回的是第1次找到的元素的索引,未找到返回-1

```js
let arr = [3,4,5,6,33,55];
let sum = arr.find((item) =>{
    return item === 6;
})
let sum2 = arr.findIndex((item) =>{
    return item === 33;
})
console.log(sum); // 6 
console.log(sum2); // 索引4
```





## every检测

检测数组元素是否满足指定条件；接收回调函数作为参数,功能由回调函数提供

1.  所有元素都通过检测，返回true, 只要有一项元素不满足检测条件则返回false, 不改变原数组

```js
const user = [
{name:'李四', js:89},
{name:'张三', js:79},
{name:'王五', js:69},
 ]
res = user.every(function(item){
    return item.js >= 60;
})
if(res){ //取真
    console.log('全部通过')
}
```



## some检测

注释：some() 方法用于检测数组中的元素是否满足指定条件（功能由回调函数提供）

- 只要有一个元素满足条件即停止检索，并返回true ，不改变原数组
- 接收三个参数 要检查的元素  开始位置  当前元素所属的目标对象

```js
// 遍历
let arr = ['js','bbgj','kjkjk']
arr.some((x) => console.log(x)) // js bbgj kjkjk

// 检测
let sum = arr.some(function(age){
    return age == 'js'
})
console.log(sum); // true
```



## forEach

注释：forEach：用于遍历数组元素的每一项，接收2个参数 1：功能函数 2：更改功能函数this指向的对象

- 功能函数 则接收3个参数 数组每一项，索引，数组本身

```js
let arr = [1,2,3,4,5]
arr.forEach((item,index,arr) =>{
   console.log(item,index,arr);
    console.log(this); // {name: 'xjj}
}, {name: 'xjj'})
```



## 重写forEach

```js
// 定义myFunction方法，传入fn功能函数和第二个更改this指向的参数对象
Array.prototype.myForEach = function(fn,items){
      var arr = this, // this指向调用者 --> 数组
          len = arr.length,
          arg2 = items || window;
    
    for(let i = 0; i < len; i++){
        // 更改this 指向第二个参数对象items
        fn.apply(arg2, [arr[i], i , arr]);
    }
} 

arr.myForEach(function(item,index,arr){
    // 这里this 指向xxx元素节点，
    this[index].innerHTML = item.name;
},xxx元素对象)

```



## map

map可以返回一个和原数组产生映射的新数组，新数组的成员由原始数组调用函数处理后的返回值组成，

1. map的回调函数接收四个参数，除第一个外其余三个为可选项
   1. currValue  当前遍历的值
   2. index 当前值的索引
   3. arr 被遍历的数组
   4. 映射回调函数的 this

```js
let arr = ['js','bbgj','kjkjk']
let a = arr.map(x => 'web') // 全部替换成了web 
console.log(a)
---------------
    
const bookList = [
  'The Hound of the Baskervilles',
  'On The Electrodynamics of Moving Bodies',
  'Philosophiæ Naturalis Principia Mathematica',
  'Disquisitiones Arithmeticae'
]

function test(arr) {
    return arr.map(item => {
        console.log(item,'---', this.newArr)
    }, newArr = 'xjj') 
}

rest(bookList)
```



## repeat复制

- 用于复制字符，可以指定要复制的次数，返回的时一个新的副本字符串


```js
let str = 'xjj';
let arr = str.repeat(2); 
console.log(arr); // xjjxjj
```



## slice截取

用于截取数组/字符串, 返回一个新的数组 由被截取到的元素组成，不改变原数组/字符串

- 参数：要截取的字符/数组元素的起始索引默认0，截取到第几个元素的索引位置结束
- 可以设置负数-表示从尾部截取

```js
let arr = [1,2,3,4,5,6]
let str = arr.slice(1,3); // 从索引1开始截取到索引3的位置结束，不包含索引3
console.log(str); // 2 3
```



## replace替换(重要)

1. 参数：目标字符 ，替换字符 不改变源字符串
2. 用于替换字符，返回一个由替换值或正则模式匹配项后的新字符串，
   1. 替换值可以是具体的字符/，也可以是一个每次匹配都要回调的函数
   2. 如果是回调函数，那么函数的第一个参数为将要被替换的目标字符，可以理解为旧值
   3. 第二个参数为匹配到的字符值，如果是数组则是数组值对应的索引号(逗号也会被标记索引号，但不会被返回,)，如果是纯字符同样也是索引号
   4. 如果匹配到的是插值表达式，那么第二个参数则是插值表达式内的字符量
   5. 函数的返回值将替换掉replace的第一个参数匹配到的结果

```js
let arr = 'xjjhello';
let str = arr.replace('xjj', 'zxy');
console.log(str); // zxyhello

// 利用正则
let a = 'xjjhelloxjj';
let b = a.replace(/xjj/g,'zxy'); // zxyhellozxy
```



## 正则模板替换replace

```js
// 正则的模板替换
<div class="box"></div>

// script标签用html就不会执行。可以用作模板
<script type="text/html" id="tpl">
  <h1>{{title}}</h1>
  <p>{{content}}</p>
</script>

<script>
  let oBox = document.getElementsByClassName("box")[0];
  let tpls = document.getElementById("tpl").innerHTML;

console.log(tpls);

let res = tpls.replace(/{{(.*?)}}/g, function (node, key) {
  // node 为正则匹配到的结果，key为正则结果的字符值，如果是数组则是对应索引
  return {
    title: "这是一个积木的天",
    content: "力拔山兮气盖世",
  }[key];
  // 这里return了一个对象[key]，类似对象访问 obj['xxx']
});

oBox.innerHTML = res;
```





## search搜索

- 搜索指定字符的索引，匹成功即停止搜索，匹配失败返回-1，
- 如果参数不是正则会被自动隐式转换为对于的正则式，

```js
let a = '12xjjhello'
console.log(a.search('he')); // 5,字符h索引为3然后终止搜索，字符e不会被搜索
console.log(a.search(/[a-zA-Z]/g)); // 2,索引2包含字母，条件终止
```



## split分割

- 分割字符串，并将其转换为字符串数组，


```js
let str = 'xjjhello';
let arr = str.split(' ') // 加空格分割成字段，反之按单个字符分割
```



## join连接

- 用于将数组转换成字符,返回新的字符串默认逗号分割，不改变原数组


```js
let arr = [2,3,'xjj'];
let str = arr.join(''); // 默认逗号分割, 加分号连接成一个字符段
```



## splice删除替换(重要)

1. 用于删除数组元素/替换数组元素，返回被删除的数组。会改变原数组
2. 参数：删除时开始位置，删除个数，删除后是否填充新的元素(需要填充就写)可以是数组形式填插入

```js
let arr = [1,2,3,4,5,6]
let sum = arr.splice(1,2,[22,33]); // 从索引1开始 删除2个元素，包含索引1
console.log(sum); // 2 3 返回数组，包含被删除的元素
console.log(arr); // [1,22,33,4,5,6]
```



## 合并数组

```js
let arr = ['xjj',18];
let arr2 = ['ldh',22];
arr.concat(arr2)
```



## 大小写转换

```js
let a = 'xjjhello';
console.log(a.toUpperCase()); // XJJHELLO
let b = 'HELLO WORD';
console.log(b.toLowerCase()); // hello word
```



## entries

- 方法返回一个新的**Array Iterator**对象，该对象包含数组中每个索引的键/值对
- 内部包含done和value，与对象的Object.entries不同

```js
let arr = [1,2,3,4,5]
let it = arr.entries();
coosole.log(it.next()); // 每调用一次next方法会迭代一次数组成员
console.log(it.next().value[1]); // 直接访问next方法内部的属性值
```



## sort排序

- sort采用的是原地排序法
- 默认升序排列，字母按照大写优先原则

```js
let arr = [4,3,2,'a',1,12,23,'A'];
let newArr = arr.sort(); // 排序后[1, 12, 2, 23, 3, 4, 'A', 'a']

// 为了更正确的排序，则需要提供函数
let arrList = arr.sort(function(a,b){
    if(a < b){return -1}else if(a > b){
        return 1;
    }else if(a === b){
        return 0
    }
})
// 如果比较的是纯数字 直接使用a-b即可，因为a - b只有3中结果要么负数 返回-1，要么正数返回1，要么原地不动
// 如果想倒序 直接 b - a;
let newArr = arr.sort(function(a,b){return a - b});
```



## Math.random随机

- 利用Math.random()  返回一浮点数，伪随机区间范围0-1之间，包括0 但不包括1
- 区间范围可以手动设定

```js
let arr = ['学生1','学生2','学生3','学生4','学生5']
arr.sort((a,b) =>{
    return Math.random() - 0.5; // 与数组排序类似 此处则是随机排序
})
```



## valueOf

- 不常用，一般需要时系统会自动调用该方法
- 不同类型调用该方法返回不同的结果
  - Array  返回数组对象本身
  - Boolean  布尔值
  - Date    返回一个时间戳
  - Function  返回函数本身
  - Number    返回数字值
  - Object      默认返回对象本身
  - String       返回字符串值



## Array.values

```js
// 返回一个新的可迭代对象，该对象包含数组每个索引的值
let arr = [1,2,3,4,5];
let num = arr.values();
for(let value of num){
    console.log(value)
}
```



## Array.isArray

- 用于判断目标是否事数组，而不用考虑多个作用域的因素



# 迭代器与生成器



## 生成器函数Generator

注释：Generator: 生成器函数，一种异步编程的方案，内部封装了多个内部状态(已由Promise替代)，了解即可，有3个方法如下

1. next():  返回一个由 yield表达式生成的迭代器
2. return(); 返回给定值并结束生成器状态
3. throw(); 向生成器抛出一个异常
4. 生成器函数只会在初次调用 next() 方法后开始执行
   1. 也就是 yield暂停，next恢复执行(迭代)

```js
function * genertorFn() {}; // 这是一个生成器函数

class Foo {
    *generatorFn() {}; // 这也是一个生成器函数
}

-----------------------
function * generatorFn() {
    yield 'xjj';
    return 'xjj2'
}

let gen = generatorFn();
console.log(gen.next()); // {value: 'xjj', done: false}
```



## 迭代器 iterator

- 迭代器是由生成器函数执行后返回的一个带有next()方法的对象
- 生成器对迭代器的控制由yield关键字来执行
- 迭代表示可控，
- 内部属性；
  - done：处于false表示迭代未完成，true表示已迭代完成
- 检查是否存在迭代器：num[Symbol.iterator];  如果不存在 抛出 undefined
- 实际工作中不需要显示调用 Symbol.iterator去转化成迭代器，因为实现可迭代协议的所有类型都会
  自动兼容接收可迭代对象的任何语言特性
  - 它们可使用：
  - for...of,  可解构，扩展操作符，Array.from(), 
  - Promise.all() 接收由期约组成的可迭代对象
  - Promise.race() 接收由期约组成的可迭代对象

```js
function * generator (){
    yield '姓名:xjj';
    yield '年龄:23';
    yield '爱好:吹牛';
    return 'javascript好耶';
}
let iterator = generator();
console.log(iterator.next()); // {value: '姓名:xjj', done: false}
console.log(iterator.next()); // {value: '年龄:23', done: false}
console.log(iterator.next()); // {value: '爱好:吹水', done: false}
console.log(iterator.next()); // {value: 'javascript好耶', done: true} true表示整个迭代完毕

--------------------------------------------------------
const arr = ['姓名: xjj','年龄:23', '爱好:吃饭'];

function gen(arr){
    let nextIndex = 0; 
    return {
        next:function(){
            return nextIndex < arr.length ?
                {value: arr[nextIndex ++], done:false} :
                {value: arr[nextIndex ++], done:true};
        }
    }
}
const iterator = gen(arr);
iterator.next();
```



## 数组的迭代

- 数组的方法基本都具有迭代功能，其中for...of与for循环类似
- 对象也是类数组，但不像数组一样迭代，只能遍历如for..in或Object.keys/values/entries，通过添加原型方法则可使其具有迭代功能
- 内置的数组迭代方法：values(), keys(), entries()

```js
// 迭代基于Array.iterator原型，只要对象包含这个元素属性，即使是类数组也可以迭代
let obj = {
    0:1,
    1:2,
    2:3,
    length:3,
    // 手动添加原型方法，添加到全局也行如:
    // Object.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
    [Symbol.iterator]:Array.prototype[Symbol.iterator]
}
for(let key in obj){
    console.log(key); // 不会报错 obj类数组变成了可迭代对象
}

------------分割线--模拟next()运行----
let arr = [1,2,3,4,5];
let it = arr.entries();
let newArr = [];
for(let i = 0; i < arr.length + 1; i++){
    let item = it.next(); // 添加迭代器
    // 取反迭代器内的done标记，条件成立则返回&&后面的值，条件不成立则结束程
    !item.done && (newArr[i] = item.value)
}
console.log(newArr); // 获取到arr数组的下标与元素值
```



# 数组相关

## 多维数组排序

- 利用entries迭代器实现

```js
let arr = [[56,23],[56,123,4,1],[234,56,1],[2,67,23]];
function sortArr(arr){
    let _it = entries(); // 添加迭代器方法
    let _doNext = true; // 循环终止标记
    while(_doNext){
        let _r = _it.next();
        // 取反 直到next方法内的done属性条件为true结束
        if(!_r.done){
            _r.value[1].sort(function(a,b){
                return a - b;
            })
            _doNext = true; 
        }else{
            _doNext = false;
        }
    }
}
```





## Array.from()

注释：将类数组或可迭代对象转换成一个新的、浅拷贝的数组实例

- 语法：Array.from(object, Function, thisValue)；参数分别未为：要转换的对象、回调函数、映射回调条函数this的对象

- 在函数内部使用时可以接收一个映射函数arguments

```js
let obj = {
	0:1,
	1:2,
	2:3,
	length:3
}
const newArr = Array.from(obj,function(item,index){
    // item取到的是属值1，2，3 index为索引 0，1，2
    return{
        studentId: this.prefix + item,
        order: index
    }
}, 	// 第三个参数
  { // 映射回调函数的this 方便统一管理
    prefix: 'No'
  }
)
```





## Array.of()

注释：将类数组 字符转换成数组，有返回值

- 相对于new Array()它可以值创建单个元素的数组
- 主要用于创建数组和将==一组数== 数值可以使任意类型，转换为数组

 ```js
Array.of(1,2,3,4) // 转为数组 [1,2,3,4]
Array.of(7) // 得到的是数组[7] 单个元素 长度为1，而不是像new.Array一样得到长度为7的数组
 ```





## JSON数据转数组

```js
let json = {
    "0":"jsp",
    "1":'技术胖',
    "2":'大胖叨叨逼',
     length:3
}
// 将以上json格式转换成js数组格式
let arr = Array.from(json)
//  join() 则可以将数组元素转换成字符串，
// 允许添加分隔符，默认逗号，('')加2个引号为空，即不分割
arr.join()  // jsp技术胖大胖叨叨逼
```



## 数组填充 fill

- fill();  返回一个经过填充后的数组引用，会改变原数组
- 如果填充位置 start-end；为-负数，即负数+数组长度length，得出的数为要填充的条件

```js
// 接收三个参数 要填充的值，填充开始的位置，填充截止的位置，不包括最后截止的位置
let arr = [1,2,3,4,5];
let newArr = arr.fill('a',2,4); // [1,2,'a','a',4,5]
console.log(newArr === arr); // true

```



## 数组循环 for  of

注释：遍历可迭代对象

- for(let item of arr)；arr代表要遍历的目标对象，后面可以跟如下参数方法
- arr.keys() /.values() /entries();  
  - 分别得到：索引、值、索引+值，注意：==不能遍历对象因为对象不具有可迭代性==且数组中如果包含对象会将对象显示为object而不是对象的值，如果想从包含对象的数组中正常显示对象值和属性建议使用forEach()

```js
let arr = ['jsps','刘德华',18]
for(let item of arr){// arr后面可以根据需要配置索引或值如 arr.keys()
    console.log(item) // 默认得到字符形式的值
}
--------------------------------------
for (let [index,val] of arr.entries()) {
    // 这样写法就直接得到 索引+值 ，字符形式的键值对
    console.log(index + ':' + val)
}
---------------------------------------
    for (let item of arr.entries()) {
    // 这样写法就直接得到 索引+值 ，数组形式的键值对
    console.log(item)
}
--------------
// 利用entries()实例方法生成条目实现不规则循环 
// entries 可以手动调用 next() 即需要时才调用它
let arr = ['liudehua',18,'zxy'];
let list = arr.entries()
// 开始调用
list.next().value() // 输出liudehua
**********          // 这里可以生成不规则循环的内容
list.next().value() // 输出 18
list.next().value() // 输出 zxy
```



## filter过滤

注释：filter具有遍历和过滤功能 (由函数提供)，不改变原数组

- 返回一个新的数组,  由通过函数设定的元素组成

```js
// 遍历
let arr = ['js','呵呵','前端']
arr.filter(x => console.log(x)) // js 呵呵 前端
arr.filter()

// 过滤
let arr = [1,3,4,5,6,7,66]
let sum = arr.filter(item =>{
    return item % 2 === 0;
})
console.log(sum); // 4 6 66
```



## reduce归并(重要)

注释：数组的迭代方法,为数组每个元素调用一次函数，函数由程序员提供，最后将所有元素汇总为单个值(升序)

1. element.reduce(function(value1,value2){执行体},映射回调函数的第一个参数 作为计算的初始值);   
2. 如果没有设置第三个参数则prev的默认值为数组第一项的值，curr 则从之后的索引开始依次遍历，然后每次将遍历后的项作为结果交给prev进行累加
3. 如果设置了第三个参数，则value1为第三个参数的映射，
4. 第四个参数：数组本身
5. reduceRight()；  该方法与reduce相同，区别在于它从右至左迭代
6. 总结：凡是用到 += 这种的都可以使用 reduce简化

```js
let a = [1,2,3,4,5];
let b = a.reduce((prev, curr, index, a) => {
    return prev + curr;
},0)
console.log(b); // 15
// 第三个参数默认为0可以不写(如果是字符类的一定要写0)，映射第一个参数prev 表示其初始值
// val一开始是初始值，之后每次迭代它都是上一次的归并值和作为第一个参数，
```





## 数组扁平化flat

注释：意思将一组二维乃至多维的数组拍平为1维的数组，自动忽略数组稀疏空位

1. flat();  该方法来自数组原型，内部自动递归数组/对象后将其合并为一个新的数组并返回新数组
2. 注意该方法属于数组原型，对象要使用需要先将对象转换为数组才能调用该方法

```js
const obj1 = {
    name:'xjj',
    age:14,
    arr:['二维','b',1,arrs=['三维']],
    address:{
        city:[
            {'湖南':'邵阳三维数组'},
            {'广东': '深圳三维数组'}
        ]
    },
}
// Infinity表示无论多少维都拍平为一维数组，如果只有2层写个2即可
Object.values(obj1).flat(Infinity) 
```



## 扁平化flatMap

- 相当于flat与map的组合

```js
let arr = ['123','234','456'];
let newArr = arr.map(function(item){
    return item.split('');
}).flat(); // map + flat实现扁平化

// flatMap改进版
let newArr2 = arr.flatMap(function(item){
    return item.split('')
})
console.log(newArr2)
coosole.log(newArr2 === arr); // false
```



## 手写扁平化

- 自写原型方法

```js
let arr = [1, 3, 4, 1, 3, 5, [2, 5, "xjj"], [2, 3, 5, [3, 56, 7]]];
Array.prototype.flaten = function(){
    // 谁调用this就指向谁(这里指向arr数组)
    let _this = this;
    let toStr = Object.prototype.toString;
    // 利用保存的原型toString方法判断数值类型
    if(toStr.call(_this) !== '[object Array]'){
        throw new Error('该方法只支持数组使用')
    }
    let fArr = [];
    // 遍历数组对象
    _this.forEach(function(item){
        toStr.call(item) === '[object Array]' ?
          (fArr = fArr.concat(item.flaten())) :
          fArr.push(item)
    }); // 扁平化完成后还可以进行去重
    return fArr.filter(function(item,index){
        return fArr.indexOf(item) === index;
    })
}
let num = arr.flaten();
```





## 树形数据结构化

1. 将一个扁平化的数组嵌套成树形状

```js
 const rootList = [
   { id: 1, parent: null, text: "菜单1" },
   { id: 11, parent: 1, text: "菜单1-1" },
   { id: 12, parent: 1, text: "菜单1-2" },
   { id: 2, parent: null, text: "菜单2" },
   { id: 21, parent: 2, text: "菜单2-1" }
 ];

function getTreeList(rootList,id,list){
    for(let item of rootList){
        if(item.parent === null){
            list.push(item)
        }
    }
    // 在一级数据list下继续遍历追加二级数据
    for(let val of list){
        val.children = [];
        // val.id只有1和2，递归是按照先1 比对parent
        getTreeList(rootList,val.id, val.children)
    }
    return list;
}
let res = getTreeList(rootList,null,[]); // 传入数据集合，将parent为空的项作为一级数据，[]用于存储
```



## 数组去重

- 双for循环实现 (不推荐)  

```js
let arr = [3,64,343,64,3,33,343,2];
function uniqueArr(array){
    let newArr = []; // 空数组
    let flags; // 标记 方便循环外部push
    for(let i = 0; i < array.length; i++){
        flags = false; // 将标记修改为false
        for(let j = 0; j <newArr.length; j++){
            if(newArr[j] == array[i]){
                flags = true;
                break;
            }
        }
       // 取反 即两数不相等 则追加到新数组
        if(!flags){
            newArr.push(array[i])
        }
    }
    return newArr;
}
let sum = uniqueArr(arr).sort(function(a,b){
    return a - b;
})
console.log(sum); // [2, 3, 33, 64, 343]
```

- 去重方式二: **filter + indexOf**  (推荐)

```js
var commonTools = {
    unique: function (arr) {
        return arr.filter(function (item, index) {
            return arr.indexOf(item) === index;
            // item -> 2    indexOf返回索引位 -> 0  === index 0  true
            // item -> 4    indexOf返回索引位 -> 1  === index 1  true
            // item -> 5    indexOf返回索引位 -> 2  === index 2  true
            // item -> 56   indexOf返回索引位 -> 3  === index 3  true
            // item -> 6    indexOf返回索引位 -> 4  === index 4  true
            // item -> 56   indexOf返回索引位 -> 5  === index 3  false -> 重复:不返回值
            // item -> 5    indexOf返回索引位 -> 6  === index 2  false -> 重复:不返回值
            // item -> 6    indexOf返回索引位 -> 7  === index 4  false -> 重复:不返回值
            // item -> int  indexOf返回索引位 -> 8  === index 8  true
            // item -> Gen  indexOf返回索引位 -> 9  === index 9  true
            // item -> int  indexOf返回索引位 -> 10 === index 8  false -> 重复:不返回值
        })
    }
}

let arr = [2, 4, 5, 56, 6, 56, 5, 6, 'int', 'Gen', 'int']
```

- 去重方式三 **forEach + indexOf/includes**

```js
let arr = [1,1,2,34,45,23,5,6,4,654,5,3,4,21,1,2];
function uniqueArr(array){
    let _arr = []; // 空数组用于追加去重后的元素
    array.forEach(function(item){
        // 这里使用es6的includes取反替代indexOf也行，注意indexOf对NaN无效
        // if(!_arr.includes(item)){_arr.push(item)}
        if(_arr.indexOf(item) === -1){
            _arr.push(item);
        }
    })
   return _arr;
}
// [1, 2, 21, 23, 3, 34, 4, 45, 5, 6, 654]
console.log(uniqueArr(arr).sort((a,b) =>{return a - b})); 
```

- ES6set实现

```js
let arr = [1,1,2,34,45,23,5,6,4,654,5,3,4,21,1,2];
let num = arr.sort(function(a,b){return a - b}); // Set去重前先排序
console.log(new Set(num)); // new Set自动去重
```



## 去重与扁平化

```js
let arr = [1, 3, 4, 1, 3, 5, [2, 5, "xjj"], [2, 3, 5, [3, 56, 7]]];
function uniqueArr(array) {
  return array.filter(function (item, index) {
    return array.indexOf(item) === index;
  });
}
let sum = arr.flat(Infinity);
console.log(uniqueArr(sum).sort());
```



## 浅复制copyWithin

```js
let arr = [1,2,3,4,5,6]
// 参数：目标位置，开始复制位置，结束位置
let newArr =o arr.copyWithin(1, 3, 4); // 1 4 3 4 5 6
```



## 数组的entries/values/keys

- 与对象的Object.entries/values/keys不同的是 数组对应的方法如下：
  - arr.entries  返回数组索引+对应值的 可迭代对象，
  - arr.values  返回值数组元素的可迭代对象，需要使用for...of 遍历它
  - arr.keys  返回数组索引的可迭代对象，需要使用for...of 遍历它



## 数组转对象

- 利用循环添加进新的对象

```js
let arr = [1,2,3,4,'xjj'];

let obj = {};
arr.forEach((item,index) => {
    obj[index] = item;
})
```



# 对象相关



## Object.create

- 使用现有的对象来提供新创建对象的 prototype,可以手动配置constructor
- 可以使用变量进行接收，
- 该方法创建的对象本身是没有原型方法的，必须利用现有对象来为其提供原型
- 同样Object.create() 也可创建一个没有原型的对象

```js
let hd = Object.create(Fn.prototype/window,{
    // 配置
    constructor:{
        value:xxx,
        configurable:true,
        enumerable:true,
        writable:true
    }
})

let num = Object.create(window,{
    name:{
        value:'xjj'
    }
})

// 创建一个没有原型的对象
let user = Object.create(null)
```



## Object.setPrototypeOf

- 该方法也可以设置自定义对象原型,与Object.create类似

```js
let parent = {name:'xjj',age:23};
let son = {name:'ldh',age:22}
let hd = Object.setPrototypeOf(son,parent); // 继承parent的原型
```





## Object.assign

1. 将所有可枚举的属性值从另外一个或多个源对象分配到目标对象,并返回目标对象(也可以用变量接收)
2. 注意点：对象的键名不能重复，否则源对象键名会覆盖目标对象的键名，且对于嵌套对象无法实现深拷贝
3. 语法: Object.assign(目标对象,源对象),无论有多少源对象，第一个都是目标对象
4. 原理: 通过调用源对象的getter方法读取属性再调用目标对象的setter方法 将读取到的属性设置上去
5. 可用于浅复制

```js
let test = {name:'xjj',age:18};
let text = {sex:'男',age:15};
let sum = Object.assign(test,text)
console.log(test) // name:'xjj,age:15,sex:'男'
console.log(sum) // name:'xjj,age:15,sex:'男'
console.log(test === sum); // true
```



## 对象遍历for...in

会忽略Symbol属性

1. 遍历对象的key键
2. 对象[key]; 则为值
3. 若key键为数字类对象会自动排序，若想不按照顺序排列可以在key键前使用 + 号欺骗程序

```js
let obj = [
    name:'xjj',
    age:33
]
for(let key in obj){
    console.log(key); // name age
    console.log(obj[key]); // xjj 33
    console.log(key, obj[key]); // name: xjj , age:33
}
```





## 对象赋值

注释：ES6允许将变量直接赋值给对象

```js
let name = '刘德华';
let age = 18;
let obj = {name,age}
console.log(obj) // 刘德华 18
```



对象属性添加规范

注释：建议使用Object.assign(要赋值的对象, {赋值})

```js
let obj = {};
obj.x = 3; // 能添加成功，不建议
Object.assign(obj, {name:'xjj'}); // 为对象obj添加属性name(推荐)
```



## 计算属性

- 用于动态复制对象的键属性：JS运行时会将其当作表达式解析而不是字符
- 它可以是一个动态的变量，也可以是一个复杂的函数表达式

```js
let nameKen = 'name';

let obj = {
    // 将动态变量放在[]内即可,它就是一个表达式 结果 = 'name'
    [nameKen] : 'xjj'
}
obj.name; // xjj
```





## 对象转数组Object

注释：以数组形式返回对象自身可枚举属性，会忽略Symbol属性

1. Object.keys();    对象转数组后的键
2. Object.values(); 对象转数组后的值
3. Object.entries(); 对象转数组后的键值对
4. 对象转数组可以调用数组方法，处理完毕后还可以将其再次转为对象
   1. 使用 Object.fromEntries(arr)

```js
let obj = [
    name:'xjj',
    age:33,
    sex:'男'
]
Object.values(obj) //  xjj 33 男
Object.keys(obj)   // name age sex
Objext.entries(obj) // 键值对 name:xjj, age:33, sex:'男'
Object.entries(obj).flat(要拍平的维数); // 获取键值对后再转城一维数组
```



## 属性标志和描述符

- value: 包含属性实际的值, 默认值 undefined
- writable  是否可读写
- enumerable 是否可枚举(遍历)
- configurable  是否可配置(删除)
- getOwnPropertyDescript(目标对象, 要查看的对象属性)； 返回对象属性的详细描述
- 通过 defineProperty可以修改属性标志和描述符

```js
let obj = {
    name: 'xjj', // [value属性的实际值 xjj]
}
Object.defineProperty(obj, 'name', {
    value:'xjj改成xxx',
    weritable: true,
    enumerable: true,
    configurable: true
})
```





## 访问器属性getter和setter

- 对象属性分两种，
  - 一种是数据属性：writable/enumerable/configurable 等
  - 一种是访问器属性 ；getter和setter，用get和set标识
  - 当我们操作对象属性的时候它在幕后运行，
  - 访问器属性有四个特性配置
    - configurable, 是否可配置
    - enumerable  是否可枚举
    - get 函数  读取属性时调用
    - set 函数   设置属性时调用
- 访问器属性不能直接定义，必须通过Object.defineProperty() 方法 设置它
- 在defineProperty描述符中 数据属性 writable/enumerable与get、set不能同时存在，否则报错

```js
let user = {
    name: 'xjj',
    get names() {
         return this.name
    },
    set names(newVal) {
        if(newVal.length < 4) {
           throw new Error('设置的字符长度不够')
        }
       this.name = newVal
        
    }
}

user.names = 'ldh'; // 触发set 设置的字符长度不够
```





## defineProperty

作用: 劫持数据，给对象进行扩展，属性特性的设置，(劫持的对象一般为空对象)

1. Object.defineProperty;接收三个参数,返回修改后的对象，也叫做 ES5数据劫持
   1. 参数1：目标对象
   2. 参数2：目标对象的属性(修改原有属性或添加新属性)
   3. 参数3：设置属性值和特性配置
2. 通过defineProperty定义后的属性，默认特性全部为 false
   1. value  定义属性值，如果是添加，则默认undefined，如果是修改 则默认为原始数据
   2. enumerable 是否可被for...in, Object.keys()枚举，
   3. configurable 是否可删除定义后的属性，以及除value和writable特性外的其他特性是否可修改
   4. writable 是否可重写/赋值
3. defineProperty在定义每一个属性时，都会对应产生一个访问器 get和set，用于处理属性的访问和设置
   1. setters 设置属性时触发的函数，不能直接return劫持对象的已有属性，会陷入死循环，需要经过中转属性
   2. getters 获取属性时触发的函数
   3. 访问器和属性描述符二者不能同时存在，只能二选一
4. defineProperty并不能对数组也进行相关操作，可以通过函数封装实现对数组的操作
5. Object.getOwnPropertyDescriptor()方法可以获取对象属性的描述情况，接收2个参数：目标对象和属性
   1. 新增的 getOwnPropertyDescriptors(); 可以读取对象多个属性，接收一个参数：目标对象

```js
let obj = {
    name:'xjj',
    age:23
}
let obj2 = Object.defineProperty(obj,'name',{
    value:'name-xjj变Hi', // 修改obj的name属性的值
    writable:true, 
    enumerable:true, 
    configurable:true
})
console.log(obj.name); // 我修改了xjj
console.log(obj.prototype === obj2.prototype); // true
obj2.name = '我又修改了xjj'
// 保持defineProperty定义时的状态，不允许继续修改
console.log(obj2.name); // 我修改了xjj，

for(let key in obj2){
    // 如果enumerable为false,则枚举出来的是未经过defineProperty定义之前的原始数据
    console.log(obj2[key]); // xjj 23
}

---------分割线-----defineProperty的--get/set---
let _default = 0;
Object.defineProperty(window,'a',{
    get(){
        console.log('调用劫持属性，我被触发啦');
        // 这里将 ++ _default 赋值给a,如果直接return a; 外部再访问a，会直接陷入死循环
        return ++ _default;
    }
})
if(a === 1 && a === 2 && a === 3){
    // 调用劫持属性，我被触发啦(触发了3次)，You win... 正常输出一次
    console.log(a); // 第四次触发get函数 a === 4
    console.log('You win...'); 
}
```



## defineProperty应用

1. 使用vite搭建服务

   1. npm init -y  
   2. npm add vite -D
   3. 将脚本调式代码更改为  "dev": "vite"
   4. npm run dev 启动服务器即可调式程序
   5. 将html页面的script脚本 类型更改为 type="module"；因为vite是基于ES6的commjs模块解析的


```js
<div>
  <input type="text" placeholder="姓名" id="username">
  <input type="text" placeholder="年龄" id="age">
  <input type="text" placeholder="邮箱" id="email">
  <input type="text" placeholder="电话" id="tel">
  <button  id="submit">提交</button>
</div>
<h2 class="h2">DOM渲染区</h2>
<div id="infoTable"></div>

<script>
 ;(function (doc){
        let oUsername = doc.querySelector('#username');
        let oAge = doc.querySelector('#age');
        let oEmail = doc.querySelector('#email');
        let oTel = doc.querySelector('#tel');
        let oSubmit = doc.querySelector('#submit');
        let oInfoTable = doc.querySelector('#infoTable');
        
        // 1 初始数据 传入userInfo对象和渲染DOM
        let userInfo = observer({
            username:'',
            age:'',
            email:'',
            tel:''
        },oInfoTable);
     
        // 2 启动函数
        let init = function () {
            bindEvent();
        }
        
        // 3 监听函数
        function bindEvent () {
            oSubmit.addEventListener('click', handleSubmitClicl,false)
        }
        
        // 4 设置监听函数处理程序
        function handleSubmitClick () {
            // 获取用户输入值
            let _username = oUsername.value.trim();
            let _age = oAge.value.trim();
            let _email = oEmail.value.trim();
            let _tel = oTel.value.trim();
            
            // 属性存在且不为初始值(或上一次的旧数据)，则进行赋值/更新属性值
            _username && (_username !== userInfo.username) && (userInfo.username = _username);
            _age      && (_age !== userInfo.age)    && (userInfo.age = _age);
            _email    && (_email !== userInfo.emil) && (userInfo.email = _email);
            _tel      && (_tel !== userInfo.tel)    && (userInfo.tel = _tel);
            
            // 赋值完毕后清空输入框
            oUsername.value = '';
            oAge.value = '';
            oEmail.value = '';
            oTel.value = '';
        }
        
        // 5 执行启动函数
        init();
    })(document)

// 6 核心功能
function observer (userInfo, newDom) {
    // 获取存入本地的信息 并创建一个空对象存放数据 用于打入DOM节点
    let _storageInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
    let _reInfo = {};
    
    // 7 核心功能的启动函数
    let init = function () {
        // 数据处理函数-处理本地存取信息->对象数据->用户信息
        initData(_storageInfo, _retInfo, userInfo);
        // DOM渲染函数
        initDom();
    }
    
    // 8 数据处理函数、
    function initData (storageInfo, retInfo, userInfo) {
        for(let k in storageInfo) {
            // 如果用户信息为空 则将本地数据赋值过去
            if(!userInfo[k]) {
                userInfo[k] = storageInfo[k];
            }
        }
        
        // 如果用户信息不为空 则直接将此次用户输入值赋值过去
        for(let k in userInfo) {
            (function (k) {
                // 劫持空对象retInfo 为其添加/修改数据
                Object.defineProperty(retInfo, k, {
                    get () {
                        return userInfo[k]; // 获取用户输入信息return出去
                    },
                    set (newValue) {
                        userInfo[k] = nawValue; // 每次触发更新视图数据
                        localStorage.setItem('userInfo',JSON.stringify(userInfo));
                        // 动态渲染DOM
                        document.querySelector(`.__${k}`).innerHTML = userInfo[k];
                    }
                })
            })(k);
        }
    }
    
  // 9 将数据打入DOM
    function initDom (retInfo,dom) {
        dom.innerHTML = obj2(retInfo);
    }
    function obj2 (info) {
        return `
        <h1>姓名: <span class='__username'>${info.username || ''}</span></h1>
        <h2>年龄: <span class='__age'>${info.age || ''}</span></h2>
        <h3>邮箱: <span class='__email'>${info.email || ''}</span></h3>
        <h3>电话: <span class='__tel'>${info.tel || ''}</span></h3>
        `
    }
}
</script>    
```





## Object.defineProperties

注释：与 defineProperty 相似，区别在于defineProperties可以定义或修改多个属性

```js
const obj = {name:'xjj',age:20};
Object.defineProperties(obj,{ 
    // 修改多个属性
    name:{
        value:1,
        writable:false
    },
    age:{value:2}
})
console.log(obj); // obj输出 {a:1, b:2}
```



## hasOwnProperty();

注释：判断对象自身属性中是否有指定的属性，排除原型上的属性，返回布尔值

```js
const sut = {name:'xjj'};
sut.deso = 43;
console.log(hasOwnProperty('deso')); // true
// sut自身已拥有 name与prototype1两个属性
for(let key in sut){
 console.log(sut.hasOwnProperty(key)); // true 自身拥有属性name与prototype1   
 console.log(sut.hasOwnProperty('toString')); // false  toString属于原型属性，不是自身属性
 // 该属性没有被JS保护，如果担心某个属性名与hasOwnPropertype同名，使用原型检测
 Object.prototype.hasOwnProperty.call(sut,'deso'); // true
}
```



## getOwnPropertyNames()

注释：以数组形式返回指定对象自身的属性名(对象成员)，包括不可枚举属性，但不包括Symbol值，

```js
let obj = {
    a:1,
    b:3
}
Object.defineProperty(obj,'b',{
    value:77,
    enumerable:false // 不可枚举
})
let obj2 = Object.getOwnPropertyNames(obj);// 获取obj的属性包括不可枚举属性
```





## freeze对象冻结

1. Object.freeze(要冻结的对象/数组)；返回传递对象而不是被冻结对象的副本
2. 冻结后对象属性不能再被修改与遍历
3. freeze分浅冻结与深冻结，浅冻结依然可以修改第二层对象的属性

```js
let obj = {
    prop:3，
    c:{
      age:12
   }
}
Object.freeze(要冻结的对象)
obj.prop = 33; // 无法修改 输出依然是{prop:3}
obj.c.age = 77; // 嵌套对象依然可以修改 输出 c.age:77
// 检查一个对象是否被冻结
console.log(Object.isFrozen(obj)); // 如果对象被冻结返回true
```

## 深冻结函数

```js
function deepFreeze(obj) {
    // 获取对象的属性名
    let propName = Object.getOwnPropertyNames(obj);
    // 冻结自身之前先冻结属性
    propName.forEach(function (name) {
        let prop = obj[name];
        // 如果prop是个对象 冻结它
        if (typeof prop == 'object' && prop !== null) { }
        deepFreeze(prop);// 递归冻结
    })
    return Object.freeze(obj);
}

let obj1 = { name: 2 };
deepFreeze(obj1)
```



## preventExtensions禁止扩展

注释：可以使一个对象变得不可扩展，无法添加新的属性，返回不可扩展的原对象

1. 该方法只阻止扩展自身属性，不阻止对原型属性的扩展

```js
cosnt obj = {name:'xjj'};
Object.preventExtensions(obj);// 禁止扩展该对象的属性
Object.defineProperty(obj,'foo',{value:'Good'});
console.log(obj); // 报错，对象属性无法扩展
----------分割线---------
cosnt obj = {name:'xjj'};
obj.__proto__.c = 88;
console.log(obj); // {name:'xjj'}; 且原型属性c被添加成功
```



# class类

注释：原型继承的语法糖

1. class 关键字创建类，(类没有变量提升)
2. extends  子类继承 某个父类；
3. super   关键字 指向父类 搭配extends实现继承父类属性和方法  
   1. class 类属于函数， constructor为函数提供逻辑代码，当调用new创建实例时调用，this指向实例对象
   2. new class类名 = 创建类的实例对象
   3. super 在子类中调用必须写在构造函数内部的最前面
4. class类创建的构造函数 原型上的方法默认不可枚举
5. 类与函数一样可以是匿名表达式，可以是声明式，可以被传递，被return返回，被赋值等
6. 类没有函数作用域，但有块作用域
7. 类中的方法如果被传递到别处调用可能会丢失this,
   1. say = () =>{};  利用函数表达式包装可以保证this正确指向其对象引用,或者利用遍历保存this
8. 类同样可以使用 instanceof, 和 xxx.prototype.isPrototypeOf(jjj)
9. 类与函数一样，可以在任何地方定义

```js
// 利用class关键字创建类 规定类名首字母大写
class Parent {
    // 添加到this的所有内容都会存在于不同实例上，因为new的时候就会调用constructor
    constructor(val,age){
        this.val = val;
        this.age = age;
        // 方法定义在constructor种就是属于实例
        this.say = function() {
        console.log(1000)
      }
    }
    // say() {} 如果放内块就属于class原型
}
console.log(Parent === Parent.prototype.constructor); // true
// 原型上实际上挂载有2个方法 constructor 和say
console.log(Object.getOwnPropertyNames(Parent.prototype)); // constructor say

class Son extends Parent{
    constructor(val,age, item){
        // 继承父类属性与方法。super可以传递参数给父类
        super(val,age)
        // 同时也可以调用父类的方法
        super.say()
        // 同时拥有自身的属性
        this.item = item;
    }
}
// 创建新的实例对象
const son = new Son('xjj', 19, '我给item传值')
console.log(son.val, son.age); // xjj 19
son.say(); // 1000

--------------------
// 利用纯函数重写
function User(name){
    this.name = name;
}

User.prototype.say = function(){
    let name = 'hello';
    console.log(name); // hello
    console.log(this.name); // xjj ,因为内部有系统创建的constructor指回函数本身
}
const user = new User('xjj');
user.say(); // xjj
```



## 类的实例化

使用 new 调用类构造函数时指向如下操作：与普通构造函数类似

- 在内存中创建一个新对象
- 这个新对象内部的 [__proto__] 指针被赋值为构造函数的原型对象 prototype 
- 构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象[实例化对象]）
- 执行构造函数内部的代码（给新对象添加属性）
- 类的所有实例共享一个原型对象



## class继承

1. 类的实例对象共享一个原型，无论实例化出多少个实例，这样就能继承父类属性并且页可以拥有自身的私有属性
2. 构造函数也好，class也好，内部的this都是指向其实例化对象

```js
class Perle {
    constructor(name){
        this.name = name;
    }
    eat(){
        console.log(`${this.name} eat something`)
    }
}

// 子类继承
class Student extends Perle {
    constructor(name,age){
       // 利用关键字super继承父类的name 并拥有自身的age属性
       // super类似ES5中的Perle.call(xxx)用法，因此class是个语法糖
        super(name)
        this.age = age;
    }
    sayHi(){
        console.log(`姓名:${this.name}, 学号 ${this.age}`)
    }
}

let a = new Student('xjj',18);
a.say(); // 名:xjj, 学号 18
```





# 代理与反射

- 代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。
- 具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对
  目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制

## Proxy代理器

注释：Proxy 是一个构造函数，返回一个代理对象，(一般被代理的对象不能为空)

- 也称作拦截器，用于创建一个对象的代理，
  - 从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等，详细参考文档

- new.Proxy(target, handler);  接收2个参数
  - target    包装的目标对象，可以是对象，数组，函数，或者另一个代理
  - handler， 一个处理函数的集合对象
- proxy._proto__顶端就是Object了，上面不再有其它原型了，因此不能使用 instanceof 检测符
  - 严格相等可以用来区分 代理与目标对象
- Proxy是ES6新增API，ES5是 defineProperty

```js
const target = {
  id: 'target'
};

const handler = {};

const proxy = new Proxy(target,handler);

// 访问到的是同一个对象的属性值: 'target'
console.log(target.id); 
console.log(proxy.id);

// 通过代理进行的操作会被转发到target，
proxy.name = '王大伟';
console.log(proxy); // [Target]: id:'target' name: '王大伟'
console.log(target); // {id:'target', name: '王大伟'}

// 同样 给目标对象直接设置属性 会反应在两个对象上(proxy, target)；因为两个对象访问的是同一个值
target.id = 'GGG';
console.log(proxy.id); // GGG
console.log(target.id); // GGG

// 检测2个对象自身是否包含有 属性 id
console.log(target.hasOwnProperty('id')); // true
console.log(proxy.hasOwnProperty('id')); // true
```



```js
onst parson = {
    name:'xjj',
    age:22
}
// 定义代理器处理函数 指定它要做些什么
let handler = { 
    // 拦截对象属性的读取
    // target为目标对象本身,prop为目标对象的属性, receiver为代理对象
    get:function(target,prop,receiver){
        console.log('你在访问Proxy');
        return target[prop];
    },
    // 拦截对象属性的设置，
     // target为目标对象本身,prop为目标对象属性的旧值, newVal为新值
    set:function(target,prop,newVal){
        target[prop] = newVal
    }
}
let proxy = new Proxy(person,handler); // 代理对象 并调用拦截处理函数，所有操作要通过proxy进行
console.log(proxy.age); // 你在访问Proxy 22,即所有对代理对象的访问必须先经过Proxy代理函数的处理
```





## 捕获器

- 使用代理的主要目的是可以定义捕获器（trap）。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。
- 每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。
- 每次在代理对象上调用这些基本操作时，代理可以在这些操作转发到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为，Object.create也是代理的一种
- 在操作系统中，捕获器是程序流中的一个同步中断，可以暂停程序流，转而执行一段子例程，之后再返回原始程序流
- 捕获器主要常用有 set ,get，has，详情参照MDN文档
  - 不同的操作都会触发相应的捕获器，设置代理对象属性触发set,读取对象属性触发 get

```js
let target = {
    foo: '王大伟'
}

let handler = {
    get() {
        // 捕获器内的this指向 handler也就是自身
        console.log(this);
        return 'handler 被触发'
    }
}

let proxy = new Proxy(target, handler);
console.log(target.foo); // 直接访问目标对象不会触发捕获器get
console.log(proxy.foo); // handler 被触发，通过代理的操作 触发捕获器get

console.log(Object.create(target).id); // 不会触发捕获器get
console.log(Object.create(proxy).id); // 过代理的操作 触发捕获器get
```



## 捕获器的不可变性

- 捕获器是知道目标对象的上下文和函数签名的(因为内部绑定了this)，但捕获器具有不可变性 (指目标对象的属性如果不可配置，读写时，捕获器不能改变其特性)，否则会抛出错误

- 比如：目标对象的name 属性，是 configurable: false; 时，捕获器 去 return name 会抛出错误

```js
const target = {
  id: '王大伟',
  age:23
};

Object.defineProperty(target, 'age', {
    configurable: false,
    writable: false,
    value: 99
})

const handler = {
    get(tar,per,rece) {
        return per
    }
}

const proxy = new Proxy(target, handler);

console.log(proxy.age); // 抛出错误如下：
// 代理上的'get':属性'age'是代理目标上的一个只读和不可配置的数据属性，但代理没有返回它的实际值 
```





## 捕获器参数和API

- 所有的捕获器都可以访问响应的参数，基于这些参数可以重建被捕获方法的原始行为，
- 如get 捕获器会接收到三个参数：
  - 目标对象()，查询的属性(键)，代理对象本身
  - 基于这些参数可以重建捕获器方法的行为

```js
const target = {
    name: '王大伟',
    age:29
}

const handler = {
    get(tarTarget, property, receiver) {
        console.log(tarTarget === target); // true
        console.log(property); // name
        console.log(receiver === proxy); // true
        // 重建捕获器方法的行为
        return tarpTarget[property] + 'hello'
    }
}

const proxy = new Proxy(target, handler);
proxy.name;
console.log(proxy.name); // 王大伟hello, 触发捕获器重建的行为
```



## 反射Reflect

- 反射 API 为开发者准备好了样板代码，用于操作对象，在此基础上开发者可以用最少的代码修改捕获器的方法
- 反射API 的方法与Object上的同名方法作用相同，并且与Proxy对象的方法也都一 一对应，这样在Proxy内可以很方便的调用对应的Reflect方法完成默认行为
- 反射API有很多详细参见MDN：
  - Reflect.defineProperty()   用于拦截对对象的返回布尔值true/false 与 Object.defineProperty相同
  - Reflect.get() ：可以替代对象属性访问操作符 
  - Reflect.has();  检查目标对象是否存在直到属性，可以替代 in 操作符
  - Refect.getPrototypeOf(obj);  返回直到对象的原型，与 Object.getPrototypeOf() 类似
  - Reflect.set();  设置对象的属性 接收4个属性：目标对象，设置的属性名，值，代理对象，
    - 返回一个布尔值的状态标记，设置成功 返回 true
  - Reflect.construct() ：可以替代 new 操作符
  - 注意：反射API是通过函数执行来操作的，也就是说它可以应用在任何函数内，包括普通函数
- 对上面的代码进行修改，使用反射API
- 注意：大多数反射API在 Object类型上也有对应方法，但反射方法适用于细粒度的对象控制与操作
  - 很多反射方法返回称作“状态标记”的布尔值，表示意图执行的操作是否成功
  - 这比那些返回对象或抛出错误的API有时候有用的多

```js
const target = {
  id: '王大伟',
  age:23
};

const handler = {
    get(trapTarget,proerty,receiver) {
        console.log(Reflect.get(trapTarget.property) === trapTarget[property]); // true
        // Reflect.get(...arguments) + 'hello',  这样写也可以
        // 或者简写也可以  Reflect.get
        return Reflect.get(trapTarget,property) + 'hello'
    }
}

const proxy = new Proxy(target,handler);

console.log(proxy.id);
console.log(target.id);

--------------set()的演示-------------------------
    const handler = {
        set(tar,prt, val, receiver) {
            return tar[prt] = val;
            // 或者利用反射API简写也可以
            如： return Reflect.set(...arguments);
        }
    } 
   
const proxy = new Proxy(target, handler);
proxy.id = 'GGG'; // 状态标记 = true， 触发set捕获器-> 设置属性值成功
console.log(proxy.id); // GGG
```



## Proxy/handler常见方法

- 代理或handler有很多内置API，与Reflect的方法是相同的，详情参考MDN文档，
- 区别只在于称呼，如 Reflect.set(), 映射属性操作，用在proxy里就叫 属性设置操作的捕获器，只要通过代理对目标对象进行设置操作就会被其捕获到，从而可以进行相关处理



## 可撤销代理

- Proxy.revocable();  可以用于对代理进行撤销，此操作不可逆，一旦撤销将不能再调用代理，否则报错
- 如果要进行撤销代理 ，则不能使用 new

```js
const target = {
  id: '王大伟',
  age:23
};

const handler = {
   get(trapTarget, property, receiver) {
    return Reflect.set(trapTarget,property,receiver)
   }
}

const {proxy, revoke} = Proxy.revocable(target, handler);
proxy.id = 'xjj'; // true

revoke(); // 撤销代理 handler: null, target: null
proxy.id = 'GGG'; // 抛出错误：无法对已撤销的代理执行“获取” 
```



## 代理的缺陷

- 当代理依赖于目标对象的实例标识(属性) 时，会丢失this，需要对其进行重写配置
- 代理内部的操作无法很好的匹配内置类型 Date() 会抛出错误

```js
const user = new User(123);
console.log(user.id); // 123
const userInstanceProxy = new Proxy(user, {});
console.log(userInstanceProxy.id); // undefined

// 重新配置
const UserClassProxy = new Proxy(User, {});
const proxyUser = new UserClassProxy(456);
console.log(proxyUser.id);
```



## 代理捕获器与反射方法

- 代理可以捕获 13 种不同的基本操作。这些操作有各自不同的反射 API 方法、参数、关联 ECMAScript
  操作和不变式。
  正如前面示例所展示的，有几种不同的 JavaScript 操作会调用同一个捕获器处理程序。不过，对于
  在代理对象上执行的任何一种操作，只会有一个捕获处理程序被调用。不会存在重复捕获的情况。
  只要在代理上调用，所有捕获器都会拦截它们对应的反射 API 操作
- 就是说只要对目标对象进行了某种操作，那么对应的捕获器就会触发对应的反射 API，然后可以对其进行处理
- API方法的详情请参照 MDN文档：以下只是列出常用的几个

```js
get() {}; // 捕获器会在获取属性值的操作中被调用。对应的反射 API 方法为 Reflect.get()

set(); //捕获器会在设置属性值的操作中被调用, 返回标记状态true/false,对应的反射API方法为 Reflect.set()

has() // 捕获器会在 in 操作符中被调用。返回布尔值，对应的反射 API 方法为 Reflect.has()

ownKeys() // 捕获器会在 Object.keys() 及类似方法中被调用。对应的反射API方法为Reflect.ownKeys()
```



# 代理模式

使用代理可以在代码中实现一些有用的编程模式



## 跟踪属性访问

- 通过捕获 get 、 set 和 has 等操作，可以知道对象属性什么时候被访问、被查询。把实现相应捕获
  器的某个对象代理放到应用中，可以监控这个对象何时在何处被访问过

```js
const target = {
    id: '王大伟',
    age: 19
}

const handler = {
    set(tar, pre, val, receiver) {
        console.log(tar[pre], ':旧值');
        console.log(val, ': 新值');
        return Reflect.set(tar[pre] = val);
        // 简写：return Reflect.set(...arguments)
    }
}
```



## 属性验证

- 对 代理对象的任何修改操作会触发set捕获器，因此可以进行相应处理
- 也可以对函数参数进行相同的限定操作

```js
class Per {
    constructor(name, age) {
        this.name = name;
        this.age = age;
        this.eat = function () {
            console.log(this.name, 'Per')
        }
    }
}

let per = new Per('xjj',19);

const handler = {
    set(tar, pro, val, receiver) {
        // 如果对代理对象的属性进行操作，限定参数值必须为number类型
        if(typeof(val) !== 'number') {
            return false
        } else {
            return Reflect.set(...arguments);
        }
    }
}

const proxy = new Proxy(per, handler);
proxy.name = 'GGG'; // 无效
proxy.name = 99; //  成功
```



## 数据绑定与可观察对象

- 通过代理可以把运行时中原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同的
  代码互相操作。比如框架的各种响应式功能

```js
// 将每次更改的数据收集到一个数组内
const userList = [];

class User {
    constructor(name) {
        this.name = name;
    }
}

const handler = {
    // new操作符 会触发 construct捕获器
    construct() {
        const newUser = Reflect.construct(...arguments);
        userList.push(newUser);
        return newUser
    }
}

const proxy = new Proxy(User,handler)
new Proxy('John');
new Proxy('xjj');

console.log(userList); // [User, User]

// 可观察对象的实现
const userList = [1];
function emit(newValue) {
    // 接收到数组元素和相应长度 ，
    console.log(newValue); // xjj, 2
}

const handler = {
    set(tar, pro, val, receiver) {
        // 设置成功返回true
        const result = Reflect.set(...arguments);
        // 如果设置成功，通知emit函数执行相应逻辑
        if(result) {
            emit(Reflect.get(tar, pro, receiver))
        }
        return result;
    }
}

const proxy = new Proxy(userList,handler)
proxy.push('xjj');
```



总结：

- 从宏观上看，代理是真实 JavaScript 对象的透明抽象层。代理可以定义包含捕获器的处理程序对象，
  而这些捕获器可以拦截绝大部分 JavaScript 的基本操作和方法。在这个捕获器处理程序中，可以修改任
  何基本操作的行为，当然前提是遵从捕获器不变式。
- 与代理如影随形的反射 API，则封装了一整套与捕获器拦截的操作相对应的方法。可以把反射 API
  看作一套基本操作，这些操作是绝大部分 JavaScript 对象 API 的基础。
- 代理的应用场景是不可限量的。开发者使用它可以创建出各种编码模式，比如（但远远不限于）跟
  踪属性访问、隐藏属性、阻止修改或删除属性、函数参数验证、构造函数参数验证、数据绑定，以及可
  观察对象。

# 字符相关

注释：

1. charAt(index): 返回指定索引位置的字符
2. 字符[index] : 获取指定位置的字符，(字符属于类数组可以使用数组的[index]访问)，系统包装类
3. charCodeAt(index); 获取指定位置字符的ASCII编码 (即键码)
4. concat():  拼接字符
5. substr(index, length); index开始位置，length要截取的长度个数 ==重点==
6. slice(index,end): index开始位置，end结束位置，截取不包括end结束位置的字符
7. str.replace('被替换的字符', '要替换上去的字符')；只替换第一个字符，不改变源字符对象
8. str.split(''):  ==字符串转为数组字符串,默认逗号分割==，转成数组字符后就可以使用reverse()反转
9. in  判断某个属性是否存在于指定对象中，也可以使用for..in 加上hasOwnProperty实现

```js
let obj = {
    name:'xjj',
    age:23
}
console.log('name' in obj); // true  name属性释放存在于obj中，返回布尔值
```





## 数据类型的判断

- typeof :  简单类型判断， 缺点： 无法判断引用类型, 可以重新封装typeof函数
- instanceof: 利用原型检测，缺点：无法判断字符类型
  - xxx.prototype.isPrototypeOf(); 也能检测原型是否存在于另一个原型上
- Object.prototype.toString.call(): 基本能判断所有类型
- 利用正则封装一个正确判断数据类型的函数

 ```js
function getType(obj) {
 let type = typeof obj;
 if (type !== "object") {
  return type;
   }
  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, '$1'); }

// instanceof 作用
function Fn() {}
let fn = new Fn()

fn instanceof Fn // true , 因为实例fn的原型链中的constructor指向了构造函数Fn
let a = []
a instanceof Array; // true ,因为a 是一个数组，它的consructor指向了 Array
Array.prototype.isPrototypeOf(a); // true,a的原型上记录了其关联自Array
 ```

封装自定义工具库:指将封装好的函数放入一个对象集合，最后集体return出去，

```js
let commonTools = {
    myTypeof: function(val){
        
    },
    myValue: function(item){
        
    }
}
```



## 判断一个数是否正数

```js
Number.isInteger(42) // true
Number.isInteger(42.5) // false
```



## 类型&值判断

1. 如果不想让一个表达式返回结果 可以 return void 即使后面跟着定时器也不会返回结果
2. 检查一个数值是不是NaN:   使用  Number.isNaN()
3. 0值相等，无论是负0还是正0 ； -0 === 0 ? // true



## Object.is()

- 判断两个参数的值是否相等，不会进行隐式转换，即严格相等===，用于解决===无法解决的问题
- 相等判断详情参可MDN文档

```js
let a = 10;
let b = 10;
console.log(Object.is(a,b)); // true
```





## 快捷键

```js
div.xxx>div.item-$*2 // 生成一个类名xxx的div并包含2个类名为item的div并且类名区别为1,2,递增
div#xxx   // 创建id名为xxx的div标签
```



## try错误捕获

- try{}  块作用域内 可以放入可能会出错的代码
- catch() {}   捕获错误，可以手动配置
- finally{}   finally一定会执行 不管try{}块内有没有发生错误

```js
console.log('嘿嘿');
console.log(a); // 报错
console.log('哈哈'); // 不执行

-------改进-----
try{
 console.log('嘿嘿');
 console.log(a); // 报错
 console.log('哈哈'); // 不执行
}catch(e){
    console.log(e) // ReferenceError: a is not defined
}finally{
    console.log('一定会执行')
}
```



# 数据类型

- ES6新增

## Symbol

实际应用没想到有啥用处

- Symbol的值为唯一标识符，不会被遍历访问到
- 即使声明相同的值，比较结果也是false,并且无法被自动转换成字符串，
- 需要手动调用toString()方法或者description

```js
var a = Symbol('xjj');
var b = Symbol('xjj');
console.log(a == b); / false
window.alert(a); // 报错-无法转换成字符串
console.log(a.toString()); // Symbol(xjj)
console.log(a.description); // xjj
```



## Map数据类型

- 可以实现真正的键值对，当然object 对象也可以实现一样的功能
- Map构造函数接收一个可迭代对象作为参数

```js
let m = new Map(); // 创建一个空的映射

// 创建一个初始化的映射
let m = new Map([
    ['key','val1'],
    ['key','val2'],
    ['key','val2'],
])
```



























